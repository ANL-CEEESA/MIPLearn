<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>miplearn.components.component API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>miplearn.components.component</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#  MIPLearn: Extensible Framework for Learning-Enhanced Mixed-Integer Optimization
#  Copyright (C) 2020, UChicago Argonne, LLC. All rights reserved.
#  Released under the modified BSD license. See COPYING.md for more details.

from abc import ABC, abstractmethod
from typing import Any, List, Union, TYPE_CHECKING

from miplearn.instance import Instance
from miplearn.types import LearningSolveStats, TrainingSample

if TYPE_CHECKING:
    from miplearn.solvers.learning import LearningSolver


class Component(ABC):
    &#34;&#34;&#34;
    A Component is an object which adds functionality to a LearningSolver.

    For better code maintainability, LearningSolver simply delegates most of its
    functionality to Components. Each Component is responsible for exactly one ML
    strategy.
    &#34;&#34;&#34;

    def before_solve(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; None:
        &#34;&#34;&#34;
        Method called by LearningSolver before the problem is solved.

        Parameters
        ----------
        solver
            The solver calling this method.
        instance
            The instance being solved.
        model
            The concrete optimization model being solved.
        &#34;&#34;&#34;
        return

    @abstractmethod
    def after_solve(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
        stats: LearningSolveStats,
        training_data: TrainingSample,
    ) -&gt; None:
        &#34;&#34;&#34;
        Method called by LearningSolver after the problem is solved to optimality.

        Parameters
        ----------
        solver: LearningSolver
            The solver calling this method.
        instance: Instance
            The instance being solved.
        model: Any
            The concrete optimization model being solved.
        stats: LearningSolveStats
            A dictionary containing statistics about the solution process, such as
            number of nodes explored and running time. Components are free to add
            their own statistics here. For example, PrimalSolutionComponent adds
            statistics regarding the number of predicted variables. All statistics in
            this dictionary are exported to the benchmark CSV file.
        training_data: TrainingSample
            A dictionary containing data that may be useful for training machine
            learning models and accelerating the solution process. Components are
            free to add their own training data here. For example,
            PrimalSolutionComponent adds the current primal solution. The data must
            be pickable.
        &#34;&#34;&#34;
        pass

    def fit(
        self,
        training_instances: Union[List[str], List[Instance]],
    ) -&gt; None:
        return

    def iteration_cb(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Method called by LearningSolver at the end of each iteration.

        After solving the MIP, LearningSolver calls `iteration_cb` of each component,
        giving them a chance to modify the problem and resolve it before the solution
        process ends. For example, the lazy constraint component uses `iteration_cb`
        to check that all lazy constraints are satisfied.

        If `iteration_cb` returns False for all components, the solution process
        ends. If it retunrs True for any component, the MIP is solved again.

        Parameters
        ----------
        solver: LearningSolver
            The solver calling this method.
        instance: Instance
            The instance being solved.
        model: Any
            The concrete optimization model being solved.
        &#34;&#34;&#34;
        return False

    def lazy_cb(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; None:
        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="miplearn.components.component.Component"><code class="flex name class">
<span>class <span class="ident">Component</span></span>
</code></dt>
<dd>
<section class="desc"><p>A Component is an object which adds functionality to a LearningSolver.</p>
<p>For better code maintainability, LearningSolver simply delegates most of its
functionality to Components. Each Component is responsible for exactly one ML
strategy.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Component(ABC):
    &#34;&#34;&#34;
    A Component is an object which adds functionality to a LearningSolver.

    For better code maintainability, LearningSolver simply delegates most of its
    functionality to Components. Each Component is responsible for exactly one ML
    strategy.
    &#34;&#34;&#34;

    def before_solve(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; None:
        &#34;&#34;&#34;
        Method called by LearningSolver before the problem is solved.

        Parameters
        ----------
        solver
            The solver calling this method.
        instance
            The instance being solved.
        model
            The concrete optimization model being solved.
        &#34;&#34;&#34;
        return

    @abstractmethod
    def after_solve(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
        stats: LearningSolveStats,
        training_data: TrainingSample,
    ) -&gt; None:
        &#34;&#34;&#34;
        Method called by LearningSolver after the problem is solved to optimality.

        Parameters
        ----------
        solver: LearningSolver
            The solver calling this method.
        instance: Instance
            The instance being solved.
        model: Any
            The concrete optimization model being solved.
        stats: LearningSolveStats
            A dictionary containing statistics about the solution process, such as
            number of nodes explored and running time. Components are free to add
            their own statistics here. For example, PrimalSolutionComponent adds
            statistics regarding the number of predicted variables. All statistics in
            this dictionary are exported to the benchmark CSV file.
        training_data: TrainingSample
            A dictionary containing data that may be useful for training machine
            learning models and accelerating the solution process. Components are
            free to add their own training data here. For example,
            PrimalSolutionComponent adds the current primal solution. The data must
            be pickable.
        &#34;&#34;&#34;
        pass

    def fit(
        self,
        training_instances: Union[List[str], List[Instance]],
    ) -&gt; None:
        return

    def iteration_cb(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Method called by LearningSolver at the end of each iteration.

        After solving the MIP, LearningSolver calls `iteration_cb` of each component,
        giving them a chance to modify the problem and resolve it before the solution
        process ends. For example, the lazy constraint component uses `iteration_cb`
        to check that all lazy constraints are satisfied.

        If `iteration_cb` returns False for all components, the solution process
        ends. If it retunrs True for any component, the MIP is solved again.

        Parameters
        ----------
        solver: LearningSolver
            The solver calling this method.
        instance: Instance
            The instance being solved.
        model: Any
            The concrete optimization model being solved.
        &#34;&#34;&#34;
        return False

    def lazy_cb(
        self,
        solver: &#34;LearningSolver&#34;,
        instance: Instance,
        model: Any,
    ) -&gt; None:
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="miplearn.components.composite.CompositeComponent" href="composite.html#miplearn.components.composite.CompositeComponent">CompositeComponent</a></li>
<li><a title="miplearn.components.cuts.UserCutsComponent" href="cuts.html#miplearn.components.cuts.UserCutsComponent">UserCutsComponent</a></li>
<li><a title="miplearn.components.lazy_dynamic.DynamicLazyConstraintsComponent" href="lazy_dynamic.html#miplearn.components.lazy_dynamic.DynamicLazyConstraintsComponent">DynamicLazyConstraintsComponent</a></li>
<li><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent" href="lazy_static.html#miplearn.components.lazy_static.StaticLazyConstraintsComponent">StaticLazyConstraintsComponent</a></li>
<li><a title="miplearn.components.objective.ObjectiveValueComponent" href="objective.html#miplearn.components.objective.ObjectiveValueComponent">ObjectiveValueComponent</a></li>
<li><a title="miplearn.components.primal.PrimalSolutionComponent" href="primal.html#miplearn.components.primal.PrimalSolutionComponent">PrimalSolutionComponent</a></li>
<li><a title="miplearn.components.relaxation.RelaxationComponent" href="relaxation.html#miplearn.components.relaxation.RelaxationComponent">RelaxationComponent</a></li>
<li><a title="miplearn.components.steps.convert_tight.ConvertTightIneqsIntoEqsStep" href="steps/convert_tight.html#miplearn.components.steps.convert_tight.ConvertTightIneqsIntoEqsStep">ConvertTightIneqsIntoEqsStep</a></li>
<li><a title="miplearn.components.steps.drop_redundant.DropRedundantInequalitiesStep" href="steps/drop_redundant.html#miplearn.components.steps.drop_redundant.DropRedundantInequalitiesStep">DropRedundantInequalitiesStep</a></li>
<li><a title="miplearn.components.steps.relax_integrality.RelaxIntegralityStep" href="steps/relax_integrality.html#miplearn.components.steps.relax_integrality.RelaxIntegralityStep">RelaxIntegralityStep</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="miplearn.components.component.Component.after_solve"><code class="name flex">
<span>def <span class="ident">after_solve</span></span>(<span>self, solver, instance, model, stats, training_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Method called by LearningSolver after the problem is solved to optimality.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>solver</code></strong> :&ensp;<code>LearningSolver</code></dt>
<dd>The solver calling this method.</dd>
<dt><strong><code>instance</code></strong> :&ensp;<code>Instance</code></dt>
<dd>The instance being solved.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Any</code></dt>
<dd>The concrete optimization model being solved.</dd>
<dt><strong><code>stats</code></strong> :&ensp;<code>LearningSolveStats</code></dt>
<dd>A dictionary containing statistics about the solution process, such as
number of nodes explored and running time. Components are free to add
their own statistics here. For example, PrimalSolutionComponent adds
statistics regarding the number of predicted variables. All statistics in
this dictionary are exported to the benchmark CSV file.</dd>
<dt><strong><code>training_data</code></strong> :&ensp;<code>TrainingSample</code></dt>
<dd>A dictionary containing data that may be useful for training machine
learning models and accelerating the solution process. Components are
free to add their own training data here. For example,
PrimalSolutionComponent adds the current primal solution. The data must
be pickable.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def after_solve(
    self,
    solver: &#34;LearningSolver&#34;,
    instance: Instance,
    model: Any,
    stats: LearningSolveStats,
    training_data: TrainingSample,
) -&gt; None:
    &#34;&#34;&#34;
    Method called by LearningSolver after the problem is solved to optimality.

    Parameters
    ----------
    solver: LearningSolver
        The solver calling this method.
    instance: Instance
        The instance being solved.
    model: Any
        The concrete optimization model being solved.
    stats: LearningSolveStats
        A dictionary containing statistics about the solution process, such as
        number of nodes explored and running time. Components are free to add
        their own statistics here. For example, PrimalSolutionComponent adds
        statistics regarding the number of predicted variables. All statistics in
        this dictionary are exported to the benchmark CSV file.
    training_data: TrainingSample
        A dictionary containing data that may be useful for training machine
        learning models and accelerating the solution process. Components are
        free to add their own training data here. For example,
        PrimalSolutionComponent adds the current primal solution. The data must
        be pickable.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="miplearn.components.component.Component.before_solve"><code class="name flex">
<span>def <span class="ident">before_solve</span></span>(<span>self, solver, instance, model)</span>
</code></dt>
<dd>
<section class="desc"><p>Method called by LearningSolver before the problem is solved.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>solver</code></strong></dt>
<dd>The solver calling this method.</dd>
<dt><strong><code>instance</code></strong></dt>
<dd>The instance being solved.</dd>
<dt><strong><code>model</code></strong></dt>
<dd>The concrete optimization model being solved.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_solve(
    self,
    solver: &#34;LearningSolver&#34;,
    instance: Instance,
    model: Any,
) -&gt; None:
    &#34;&#34;&#34;
    Method called by LearningSolver before the problem is solved.

    Parameters
    ----------
    solver
        The solver calling this method.
    instance
        The instance being solved.
    model
        The concrete optimization model being solved.
    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="miplearn.components.component.Component.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, training_instances)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    self,
    training_instances: Union[List[str], List[Instance]],
) -&gt; None:
    return</code></pre>
</details>
</dd>
<dt id="miplearn.components.component.Component.iteration_cb"><code class="name flex">
<span>def <span class="ident">iteration_cb</span></span>(<span>self, solver, instance, model)</span>
</code></dt>
<dd>
<section class="desc"><p>Method called by LearningSolver at the end of each iteration.</p>
<p>After solving the MIP, LearningSolver calls <code>iteration_cb</code> of each component,
giving them a chance to modify the problem and resolve it before the solution
process ends. For example, the lazy constraint component uses <code>iteration_cb</code>
to check that all lazy constraints are satisfied.</p>
<p>If <code>iteration_cb</code> returns False for all components, the solution process
ends. If it retunrs True for any component, the MIP is solved again.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>solver</code></strong> :&ensp;<code>LearningSolver</code></dt>
<dd>The solver calling this method.</dd>
<dt><strong><code>instance</code></strong> :&ensp;<code>Instance</code></dt>
<dd>The instance being solved.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Any</code></dt>
<dd>The concrete optimization model being solved.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iteration_cb(
    self,
    solver: &#34;LearningSolver&#34;,
    instance: Instance,
    model: Any,
) -&gt; bool:
    &#34;&#34;&#34;
    Method called by LearningSolver at the end of each iteration.

    After solving the MIP, LearningSolver calls `iteration_cb` of each component,
    giving them a chance to modify the problem and resolve it before the solution
    process ends. For example, the lazy constraint component uses `iteration_cb`
    to check that all lazy constraints are satisfied.

    If `iteration_cb` returns False for all components, the solution process
    ends. If it retunrs True for any component, the MIP is solved again.

    Parameters
    ----------
    solver: LearningSolver
        The solver calling this method.
    instance: Instance
        The instance being solved.
    model: Any
        The concrete optimization model being solved.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="miplearn.components.component.Component.lazy_cb"><code class="name flex">
<span>def <span class="ident">lazy_cb</span></span>(<span>self, solver, instance, model)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lazy_cb(
    self,
    solver: &#34;LearningSolver&#34;,
    instance: Instance,
    model: Any,
) -&gt; None:
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="miplearn.components" href="index.html">miplearn.components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="miplearn.components.component.Component" href="#miplearn.components.component.Component">Component</a></code></h4>
<ul class="">
<li><code><a title="miplearn.components.component.Component.after_solve" href="#miplearn.components.component.Component.after_solve">after_solve</a></code></li>
<li><code><a title="miplearn.components.component.Component.before_solve" href="#miplearn.components.component.Component.before_solve">before_solve</a></code></li>
<li><code><a title="miplearn.components.component.Component.fit" href="#miplearn.components.component.Component.fit">fit</a></code></li>
<li><code><a title="miplearn.components.component.Component.iteration_cb" href="#miplearn.components.component.Component.iteration_cb">iteration_cb</a></code></li>
<li><code><a title="miplearn.components.component.Component.lazy_cb" href="#miplearn.components.component.Component.lazy_cb">lazy_cb</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>