<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.0" />
<title>miplearn.components.lazy_static API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>miplearn.components.lazy_static</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#  MIPLearn: Extensible Framework for Learning-Enhanced Mixed-Integer Optimization
#  Copyright (C) 2020, UChicago Argonne, LLC. All rights reserved.
#  Released under the modified BSD license. See COPYING.md for more details.

import logging
import sys
from copy import deepcopy

import numpy as np
from tqdm.auto import tqdm

from miplearn.classifiers.counting import CountingClassifier
from miplearn.components.component import Component

logger = logging.getLogger(__name__)


class LazyConstraint:
    def __init__(self, cid, obj):
        self.cid = cid
        self.obj = obj


class StaticLazyConstraintsComponent(Component):
    def __init__(
        self,
        classifier=CountingClassifier(),
        threshold=0.05,
        use_two_phase_gap=True,
        large_gap=1e-2,
        violation_tolerance=-0.5,
    ):
        self.threshold = threshold
        self.classifier_prototype = classifier
        self.classifiers = {}
        self.pool = []
        self.original_gap = None
        self.large_gap = large_gap
        self.is_gap_large = False
        self.use_two_phase_gap = use_two_phase_gap
        self.violation_tolerance = violation_tolerance

    def before_solve(self, solver, instance, model):
        self.pool = []
        if not solver.use_lazy_cb and self.use_two_phase_gap:
            logger.info(&#34;Increasing gap tolerance to %f&#34;, self.large_gap)
            self.original_gap = solver.gap_tolerance
            self.is_gap_large = True
            solver.internal_solver.set_gap_tolerance(self.large_gap)

        instance.found_violated_lazy_constraints = []
        if instance.has_static_lazy_constraints():
            self._extract_and_predict_static(solver, instance)

    def after_solve(
        self,
        solver,
        instance,
        model,
        stats,
        training_data,
    ):
        pass

    def iteration_cb(self, solver, instance, model):
        if solver.use_lazy_cb:
            return False
        else:
            should_repeat = self._check_and_add(instance, solver)
            if should_repeat:
                return True
            else:
                if self.is_gap_large:
                    logger.info(&#34;Restoring gap tolerance to %f&#34;, self.original_gap)
                    solver.internal_solver.set_gap_tolerance(self.original_gap)
                    self.is_gap_large = False
                    return True
                else:
                    return False

    def lazy_cb(self, solver, instance, model):
        self._check_and_add(instance, solver)

    def _check_and_add(self, instance, solver):
        logger.debug(&#34;Finding violated lazy constraints...&#34;)
        constraints_to_add = []
        for c in self.pool:
            if not solver.internal_solver.is_constraint_satisfied(
                c.obj, tol=self.violation_tolerance
            ):
                constraints_to_add.append(c)
        for c in constraints_to_add:
            self.pool.remove(c)
            solver.internal_solver.add_constraint(c.obj)
            instance.found_violated_lazy_constraints += [c.cid]
        if len(constraints_to_add) &gt; 0:
            logger.info(
                &#34;%8d lazy constraints added %8d in the pool&#34;
                % (len(constraints_to_add), len(self.pool))
            )
            return True
        else:
            return False

    def fit(self, training_instances):
        training_instances = [
            t
            for t in training_instances
            if hasattr(t, &#34;found_violated_lazy_constraints&#34;)
        ]

        logger.debug(&#34;Extracting x and y...&#34;)
        x = self.x(training_instances)
        y = self.y(training_instances)

        logger.debug(&#34;Fitting...&#34;)
        for category in tqdm(
            x.keys(), desc=&#34;Fit (lazy)&#34;, disable=not sys.stdout.isatty()
        ):
            if category not in self.classifiers:
                self.classifiers[category] = deepcopy(self.classifier_prototype)
            self.classifiers[category].fit(x[category], y[category])

    def predict(self, instance):
        pass

    def evaluate(self, instances):
        pass

    def _extract_and_predict_static(self, solver, instance):
        x = {}
        constraints = {}
        logger.info(&#34;Extracting lazy constraints...&#34;)
        for cid in solver.internal_solver.get_constraint_ids():
            if instance.is_constraint_lazy(cid):
                category = instance.get_constraint_category(cid)
                if category not in x:
                    x[category] = []
                    constraints[category] = []
                x[category] += [instance.get_constraint_features(cid)]
                c = LazyConstraint(
                    cid=cid,
                    obj=solver.internal_solver.extract_constraint(cid),
                )
                constraints[category] += [c]
                self.pool.append(c)
        logger.info(&#34;%8d lazy constraints extracted&#34; % len(self.pool))
        logger.info(&#34;Predicting required lazy constraints...&#34;)
        n_added = 0
        for (category, x_values) in x.items():
            if category not in self.classifiers:
                continue
            if isinstance(x_values[0], np.ndarray):
                x[category] = np.array(x_values)
            proba = self.classifiers[category].predict_proba(x[category])
            for i in range(len(proba)):
                if proba[i][1] &gt; self.threshold:
                    n_added += 1
                    c = constraints[category][i]
                    self.pool.remove(c)
                    solver.internal_solver.add_constraint(c.obj)
                    instance.found_violated_lazy_constraints += [c.cid]
        logger.info(
            &#34;%8d lazy constraints added %8d in the pool&#34;
            % (
                n_added,
                len(self.pool),
            )
        )

    def _collect_constraints(self, train_instances):
        constraints = {}
        for instance in train_instances:
            for cid in instance.found_violated_lazy_constraints:
                category = instance.get_constraint_category(cid)
                if category not in constraints:
                    constraints[category] = set()
                constraints[category].add(cid)
        for (category, cids) in constraints.items():
            constraints[category] = sorted(list(cids))
        return constraints

    def x(self, train_instances):
        result = {}
        constraints = self._collect_constraints(train_instances)
        for (category, cids) in constraints.items():
            result[category] = []
            for instance in train_instances:
                for cid in cids:
                    result[category].append(instance.get_constraint_features(cid))
        return result

    def y(self, train_instances):
        result = {}
        constraints = self._collect_constraints(train_instances)
        for (category, cids) in constraints.items():
            result[category] = []
            for instance in train_instances:
                for cid in cids:
                    if cid in instance.found_violated_lazy_constraints:
                        result[category].append([0, 1])
                    else:
                        result[category].append([1, 0])
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="miplearn.components.lazy_static.LazyConstraint"><code class="flex name class">
<span>class <span class="ident">LazyConstraint</span></span>
<span>(</span><span>cid, obj)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyConstraint:
    def __init__(self, cid, obj):
        self.cid = cid
        self.obj = obj</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent"><code class="flex name class">
<span>class <span class="ident">StaticLazyConstraintsComponent</span></span>
<span>(</span><span>classifier=CountingClassifier(mean=None), threshold=0.05, use_two_phase_gap=True, large_gap=0.01, violation_tolerance=-0.5)</span>
</code></dt>
<dd>
<section class="desc"><p>A Component is an object which adds functionality to a LearningSolver.</p>
<p>For better code maintainability, LearningSolver simply delegates most of its
functionality to Components. Each Component is responsible for exactly one ML
strategy.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaticLazyConstraintsComponent(Component):
    def __init__(
        self,
        classifier=CountingClassifier(),
        threshold=0.05,
        use_two_phase_gap=True,
        large_gap=1e-2,
        violation_tolerance=-0.5,
    ):
        self.threshold = threshold
        self.classifier_prototype = classifier
        self.classifiers = {}
        self.pool = []
        self.original_gap = None
        self.large_gap = large_gap
        self.is_gap_large = False
        self.use_two_phase_gap = use_two_phase_gap
        self.violation_tolerance = violation_tolerance

    def before_solve(self, solver, instance, model):
        self.pool = []
        if not solver.use_lazy_cb and self.use_two_phase_gap:
            logger.info(&#34;Increasing gap tolerance to %f&#34;, self.large_gap)
            self.original_gap = solver.gap_tolerance
            self.is_gap_large = True
            solver.internal_solver.set_gap_tolerance(self.large_gap)

        instance.found_violated_lazy_constraints = []
        if instance.has_static_lazy_constraints():
            self._extract_and_predict_static(solver, instance)

    def after_solve(
        self,
        solver,
        instance,
        model,
        stats,
        training_data,
    ):
        pass

    def iteration_cb(self, solver, instance, model):
        if solver.use_lazy_cb:
            return False
        else:
            should_repeat = self._check_and_add(instance, solver)
            if should_repeat:
                return True
            else:
                if self.is_gap_large:
                    logger.info(&#34;Restoring gap tolerance to %f&#34;, self.original_gap)
                    solver.internal_solver.set_gap_tolerance(self.original_gap)
                    self.is_gap_large = False
                    return True
                else:
                    return False

    def lazy_cb(self, solver, instance, model):
        self._check_and_add(instance, solver)

    def _check_and_add(self, instance, solver):
        logger.debug(&#34;Finding violated lazy constraints...&#34;)
        constraints_to_add = []
        for c in self.pool:
            if not solver.internal_solver.is_constraint_satisfied(
                c.obj, tol=self.violation_tolerance
            ):
                constraints_to_add.append(c)
        for c in constraints_to_add:
            self.pool.remove(c)
            solver.internal_solver.add_constraint(c.obj)
            instance.found_violated_lazy_constraints += [c.cid]
        if len(constraints_to_add) &gt; 0:
            logger.info(
                &#34;%8d lazy constraints added %8d in the pool&#34;
                % (len(constraints_to_add), len(self.pool))
            )
            return True
        else:
            return False

    def fit(self, training_instances):
        training_instances = [
            t
            for t in training_instances
            if hasattr(t, &#34;found_violated_lazy_constraints&#34;)
        ]

        logger.debug(&#34;Extracting x and y...&#34;)
        x = self.x(training_instances)
        y = self.y(training_instances)

        logger.debug(&#34;Fitting...&#34;)
        for category in tqdm(
            x.keys(), desc=&#34;Fit (lazy)&#34;, disable=not sys.stdout.isatty()
        ):
            if category not in self.classifiers:
                self.classifiers[category] = deepcopy(self.classifier_prototype)
            self.classifiers[category].fit(x[category], y[category])

    def predict(self, instance):
        pass

    def evaluate(self, instances):
        pass

    def _extract_and_predict_static(self, solver, instance):
        x = {}
        constraints = {}
        logger.info(&#34;Extracting lazy constraints...&#34;)
        for cid in solver.internal_solver.get_constraint_ids():
            if instance.is_constraint_lazy(cid):
                category = instance.get_constraint_category(cid)
                if category not in x:
                    x[category] = []
                    constraints[category] = []
                x[category] += [instance.get_constraint_features(cid)]
                c = LazyConstraint(
                    cid=cid,
                    obj=solver.internal_solver.extract_constraint(cid),
                )
                constraints[category] += [c]
                self.pool.append(c)
        logger.info(&#34;%8d lazy constraints extracted&#34; % len(self.pool))
        logger.info(&#34;Predicting required lazy constraints...&#34;)
        n_added = 0
        for (category, x_values) in x.items():
            if category not in self.classifiers:
                continue
            if isinstance(x_values[0], np.ndarray):
                x[category] = np.array(x_values)
            proba = self.classifiers[category].predict_proba(x[category])
            for i in range(len(proba)):
                if proba[i][1] &gt; self.threshold:
                    n_added += 1
                    c = constraints[category][i]
                    self.pool.remove(c)
                    solver.internal_solver.add_constraint(c.obj)
                    instance.found_violated_lazy_constraints += [c.cid]
        logger.info(
            &#34;%8d lazy constraints added %8d in the pool&#34;
            % (
                n_added,
                len(self.pool),
            )
        )

    def _collect_constraints(self, train_instances):
        constraints = {}
        for instance in train_instances:
            for cid in instance.found_violated_lazy_constraints:
                category = instance.get_constraint_category(cid)
                if category not in constraints:
                    constraints[category] = set()
                constraints[category].add(cid)
        for (category, cids) in constraints.items():
            constraints[category] = sorted(list(cids))
        return constraints

    def x(self, train_instances):
        result = {}
        constraints = self._collect_constraints(train_instances)
        for (category, cids) in constraints.items():
            result[category] = []
            for instance in train_instances:
                for cid in cids:
                    result[category].append(instance.get_constraint_features(cid))
        return result

    def y(self, train_instances):
        result = {}
        constraints = self._collect_constraints(train_instances)
        for (category, cids) in constraints.items():
            result[category] = []
            for instance in train_instances:
                for cid in cids:
                    if cid in instance.found_violated_lazy_constraints:
                        result[category].append([0, 1])
                    else:
                        result[category].append([1, 0])
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="miplearn.components.component.Component" href="component.html#miplearn.components.component.Component">Component</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, instances)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, instances):
    pass</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, training_instances)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, training_instances):
    training_instances = [
        t
        for t in training_instances
        if hasattr(t, &#34;found_violated_lazy_constraints&#34;)
    ]

    logger.debug(&#34;Extracting x and y...&#34;)
    x = self.x(training_instances)
    y = self.y(training_instances)

    logger.debug(&#34;Fitting...&#34;)
    for category in tqdm(
        x.keys(), desc=&#34;Fit (lazy)&#34;, disable=not sys.stdout.isatty()
    ):
        if category not in self.classifiers:
            self.classifiers[category] = deepcopy(self.classifier_prototype)
        self.classifiers[category].fit(x[category], y[category])</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.lazy_cb"><code class="name flex">
<span>def <span class="ident">lazy_cb</span></span>(<span>self, solver, instance, model)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lazy_cb(self, solver, instance, model):
    self._check_and_add(instance, solver)</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, instance):
    pass</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.x"><code class="name flex">
<span>def <span class="ident">x</span></span>(<span>self, train_instances)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x(self, train_instances):
    result = {}
    constraints = self._collect_constraints(train_instances)
    for (category, cids) in constraints.items():
        result[category] = []
        for instance in train_instances:
            for cid in cids:
                result[category].append(instance.get_constraint_features(cid))
    return result</code></pre>
</details>
</dd>
<dt id="miplearn.components.lazy_static.StaticLazyConstraintsComponent.y"><code class="name flex">
<span>def <span class="ident">y</span></span>(<span>self, train_instances)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y(self, train_instances):
    result = {}
    constraints = self._collect_constraints(train_instances)
    for (category, cids) in constraints.items():
        result[category] = []
        for instance in train_instances:
            for cid in cids:
                if cid in instance.found_violated_lazy_constraints:
                    result[category].append([0, 1])
                else:
                    result[category].append([1, 0])
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="miplearn.components.component.Component" href="component.html#miplearn.components.component.Component">Component</a></b></code>:
<ul class="hlist">
<li><code><a title="miplearn.components.component.Component.after_solve" href="component.html#miplearn.components.component.Component.after_solve">after_solve</a></code></li>
<li><code><a title="miplearn.components.component.Component.before_solve" href="component.html#miplearn.components.component.Component.before_solve">before_solve</a></code></li>
<li><code><a title="miplearn.components.component.Component.iteration_cb" href="component.html#miplearn.components.component.Component.iteration_cb">iteration_cb</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="miplearn.components" href="index.html">miplearn.components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="miplearn.components.lazy_static.LazyConstraint" href="#miplearn.components.lazy_static.LazyConstraint">LazyConstraint</a></code></h4>
</li>
<li>
<h4><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent">StaticLazyConstraintsComponent</a></code></h4>
<ul class="two-column">
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.evaluate" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.evaluate">evaluate</a></code></li>
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.fit" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.fit">fit</a></code></li>
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.lazy_cb" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.lazy_cb">lazy_cb</a></code></li>
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.predict" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.predict">predict</a></code></li>
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.x" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.x">x</a></code></li>
<li><code><a title="miplearn.components.lazy_static.StaticLazyConstraintsComponent.y" href="#miplearn.components.lazy_static.StaticLazyConstraintsComponent.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>